<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>difflib.SequenceMatcher.find_longest_match</title>
    <meta http-equiv="X-UA-Compatible" content="IE=emulateIE7" />
<!--    <link rel="icon" sizes="32x32" href="favicon_32.png">-->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>&#128270;</text></svg>">
    <link rel="stylesheet" href="highlight.css" type="text/css">
</head>
<body class="pyfile">
<div id="source">
    <div class="highlight">
        <div id="header">
            <div class="content">
                <h1>Method: difflib.SequenceMatcher.find_longest_match</h1>
                <span>Calls: 3629, </span>
                <span>Exceptions: 0, </span>
                <span>Paths: 44</span>
                <br><a href="index.html">Back</a>
            </div>
        </div>
            <p><b>Path 1</b>: 1181 calls (0.33)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 21 (60) 6 (29) 1 (27) 3 (23) 0 (16) 13 (6) 16 (5) 31 (4) 9 (4) 5 (3) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 23 (55) 4 (24) 10 (22) 2 (16) 1 (11) 7 (11) 5 (8) 3 (8) 35 (6) 22 (6) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 21 (54) 6 (29) 1 (25) 3 (22) 0 (16) 13 (9) 9 (7) 2 (6) 16 (5) 31 (4) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 23 (55) 7 (29) 4 (24) 2 (15) 1 (12) 14 (9) 5 (8) 3 (8) 10 (7) 35 (5) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (1181) </p>
            <button class="run" title="lines run...">19 run</button>
            <button class="not_run" title="lines not run...">18 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full not_run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full not_run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 2</b>: 1011 calls (0.28)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (10) 6 (2) 2 (1) 4 (1) 8 (1) 10 (1) 12 (1) 14 (1) 16 (1) 18 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 2000 (999) 45 (4) 39 (3) 41 (3) 10 (2) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (10) 6 (2) 20 (2) 2 (1) 4 (1) 8 (1) 10 (1) 12 (1) 14 (1) 16 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 2000 (999) 45 (4) 41 (3) 10 (2) 35 (2) 38 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (1011) </p>
            <button class="run" title="lines run...">27 run</button>
            <button class="not_run" title="lines not run...">10 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 3</b>: 137 calls (0.04)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 40 (38) 23 (36) 13 (34) 46 (6) 34 (4) 38 (4) 48 (4) 57 (3) 54 (3) 29 (2) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 41 (38) 27 (36) 15 (34) 55 (7) 43 (4) 48 (4) 60 (4) 58 (4) 31 (2) 47 (2) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 25 (36) 17 (36) 15 (34) 34 (8) 40 (8) 38 (4) 42 (3) 48 (3) 29 (2) 39 (2) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 41 (40) 29 (36) 17 (34) 43 (11) 50 (9) 48 (4) 31 (2) 101 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (137) </p>
            <button class="run" title="lines run...">22 run</button>
            <button class="not_run" title="lines not run...">15 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 4</b>: 110 calls (0.03)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 16 (102) 5 (6) 29 (2) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 36 (52) 30 (51) 14 (6) 40 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 16 (102) 5 (6) 29 (2) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 36 (51) 30 (51) 14 (6) 35 (2) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (110) </p>
            <button class="run" title="lines run...">26 run</button>
            <button class="not_run" title="lines not run...">11 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 5</b>: 108 calls (0.03)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (106) 5 (2) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 5 (88) 16 (18) 11 (2) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (106) 5 (2) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 5 (54) 7 (34) 13 (18) 11 (2) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (108) </p>
            <button class="run" title="lines run...">26 run</button>
            <button class="not_run" title="lines not run...">11 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 6</b>: 103 calls (0.03)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (103) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 27 (36) 30 (36) 23 (11) 35 (9) 25 (5) 13 (4) 8 (2) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (103) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 29 (36) 7 (36) 23 (8) 15 (7) 25 (6) 13 (4) 27 (4) 10 (2) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (103) </p>
            <button class="run" title="lines run...">30 run</button>
            <button class="not_run" title="lines not run...">7 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 7</b>: 102 calls (0.03)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 21 (54) 29 (18) 13 (12) 31 (7) 33 (4) 11 (3) 14 (3) 41 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 25 (54) 41 (21) 16 (18) 45 (4) 36 (3) 55 (1) 39 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 21 (54) 26 (18) 13 (12) 31 (7) 11 (3) 14 (3) 37 (3) 41 (1) 34 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 25 (54) 33 (18) 16 (18) 45 (4) 36 (3) 41 (3) 55 (1) 38 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (102) </p>
            <button class="run" title="lines run...">25 run</button>
            <button class="not_run" title="lines not run...">12 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 8</b>: 102 calls (0.03)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (102) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 36 (55) 41 (20) 55 (7) 43 (4) 48 (4) 60 (4) 58 (4) 47 (2) 50 (1) 40 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (102) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 36 (54) 33 (18) 43 (11) 50 (9) 48 (4) 41 (4) 35 (2) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (102) </p>
            <button class="run" title="lines run...">29 run</button>
            <button class="not_run" title="lines not run...">8 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 9</b>: 85 calls (0.02)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 16 (54) 24 (18) 5 (3) 25 (2) 34 (2) 21 (2) 31 (2) 40 (2) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 25 (54) 41 (22) 47 (4) 22 (3) 36 (1) 40 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 16 (54) 21 (20) 25 (4) 34 (4) 5 (3) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 25 (54) 33 (18) 41 (8) 22 (3) 35 (2) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (85) </p>
            <button class="run" title="lines run...">26 run</button>
            <button class="not_run" title="lines not run...">11 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 10</b>: 69 calls (0.02)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (32) 33 (15) 5 (6) 23 (5) 21 (4) 2 (3) 13 (2) 40 (1) 3 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 35 (15) 2 (12) 6 (7) 4 (7) 3 (5) 5 (5) 25 (5) 23 (4) 45 (2) 15 (2) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (32) 21 (11) 25 (7) 23 (6) 5 (6) 2 (3) 15 (2) 40 (1) 3 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 23 (11) 4 (8) 27 (7) 2 (6) 25 (6) 6 (6) 1 (6) 3 (4) 9 (3) 5 (3) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (69) </p>
            <button class="run" title="lines run...">21 run</button>
            <button class="not_run" title="lines not run...">16 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 11</b>: 64 calls (0.02)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 6 (36) 21 (9) 42 (6) 11 (5) 9 (4) 5 (2) 0 (2) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 30 (36) 23 (9) 13 (5) 11 (4) 46 (3) 45 (3) 7 (2) 4 (2) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 6 (36) 9 (8) 11 (6) 13 (4) 30 (3) 34 (3) 5 (2) 0 (2) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 7 (38) 11 (8) 13 (6) 15 (4) 31 (3) 39 (3) 6 (2) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (64) </p>
            <button class="run" title="lines run...">22 run</button>
            <button class="not_run" title="lines not run...">15 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 12</b>: 57 calls (0.02)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 19 (54) 33 (3) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 25 (54) 39 (3) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 19 (54) 37 (3) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 25 (54) 39 (3) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (57) </p>
            <button class="run" title="lines run...">25 run</button>
            <button class="not_run" title="lines not run...">12 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 13</b>: 48 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 29 (19) 13 (6) 8 (6) 11 (3) 14 (3) 21 (3) 31 (3) 38 (3) 33 (1) 2 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 37 (19) 15 (12) 9 (6) 22 (3) 32 (3) 39 (3) 30 (1) 5 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 26 (18) 13 (6) 8 (6) 11 (3) 14 (3) 21 (3) 31 (3) 38 (3) 34 (1) 29 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 29 (18) 15 (12) 9 (6) 22 (3) 32 (3) 39 (3) 36 (1) 31 (1) 5 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (48) </p>
            <button class="run" title="lines run...">21 run</button>
            <button class="not_run" title="lines not run...">16 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full not_run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full not_run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 14</b>: 46 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (37) 5 (9) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 2 (15) 7 (9) 5 (8) 6 (3) 16 (3) 4 (3) 55 (1) 81 (1) 100 (1) 13 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (37) 5 (9) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 2 (15) 7 (9) 5 (7) 4 (5) 6 (3) 16 (3) 55 (1) 80 (1) 101 (1) 13 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (46) </p>
            <button class="run" title="lines run...">24 run</button>
            <button class="not_run" title="lines not run...">13 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 15</b>: 40 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (40) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 36 (36) 28 (3) 29 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (40) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 38 (37) 28 (3) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (40) </p>
            <button class="run" title="lines run...">25 run</button>
            <button class="not_run" title="lines not run...">12 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 16</b>: 36 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (36) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 41 (36) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (36) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 41 (36) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (36) </p>
            <button class="run" title="lines run...">27 run</button>
            <button class="not_run" title="lines not run...">10 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 17</b>: 34 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 13 (34) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 27 (34) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 15 (34) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 29 (34) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (34) </p>
            <button class="run" title="lines run...">31 run</button>
            <button class="not_run" title="lines not run...">6 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 18</b>: 31 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (31) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 4 (22) 16 (4) 12 (4) 6 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (31) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 4 (29) 6 (2) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (31) </p>
            <button class="run" title="lines run...">20 run</button>
            <button class="not_run" title="lines not run...">17 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full not_run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full not_run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 19</b>: 28 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 2 (13) 0 (11) 9 (4) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 16 (10) 4 (8) 12 (7) 10 (2) 6 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 2 (13) 0 (11) 9 (4) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 4 (22) 10 (4) 6 (2) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (28) </p>
            <button class="run" title="lines run...">19 run</button>
            <button class="not_run" title="lines not run...">18 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full not_run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full not_run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 20</b>: 26 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (18) 3 (2) 1 (2) 1998 (1) 34 (1) 19 (1) 2 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 4 (11) 6 (8) 36 (2) 2000 (1) 13 (1) 39 (1) 27 (1) 5 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (18) 2 (4) 1998 (1) 3 (1) 30 (1) 20 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 4 (11) 5 (7) 38 (2) 6 (2) 2000 (1) 13 (1) 35 (1) 23 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (26) </p>
            <button class="run" title="lines run...">24 run</button>
            <button class="not_run" title="lines not run...">13 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 21</b>: 25 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 11 (21) 7 (2) 5 (1) 0 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 13 (18) 12 (3) 8 (2) 7 (1) 2 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 8 (18) 15 (3) 9 (2) 5 (1) 0 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 10 (21) 16 (3) 2 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (25) </p>
            <button class="run" title="lines run...">22 run</button>
            <button class="not_run" title="lines not run...">15 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full not_run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full not_run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 22</b>: 21 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 5 (12) 33 (6) 10 (3) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 16 (12) 60 (3) 55 (3) 22 (3) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 5 (12) 21 (3) 25 (3) 10 (3) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 16 (12) 43 (3) 50 (3) 22 (3) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (21) </p>
            <button class="run" title="lines run...">29 run</button>
            <button class="not_run" title="lines not run...">8 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 23</b>: 20 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (20) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 13 (18) 15 (2) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (20) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 10 (18) 17 (2) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (20) </p>
            <button class="run" title="lines run...">29 run</button>
            <button class="not_run" title="lines not run...">8 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 24</b>: 19 calls (0.01)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 6 (18) 5 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 13 (19) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 6 (18) 5 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 10 (18) 13 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (19) </p>
            <button class="run" title="lines run...">28 run</button>
            <button class="not_run" title="lines not run...">9 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 25</b>: 18 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (18) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 16 (12) 14 (6) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (18) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 16 (12) 14 (6) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (18) </p>
            <button class="run" title="lines run...">25 run</button>
            <button class="not_run" title="lines not run...">12 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 26</b>: 17 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (13) 5 (4) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 7 (3) 22 (3) 13 (2) 10 (2) 11 (2) 19 (2) 16 (2) 14 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (13) 5 (4) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 13 (4) 10 (4) 7 (3) 22 (3) 11 (2) 23 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (17) </p>
            <button class="run" title="lines run...">26 run</button>
            <button class="not_run" title="lines not run...">11 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 27</b>: 16 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 16 (4) 3 (3) 5 (3) 9 (3) 11 (1) 26 (1) 29 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 16 (9) 45 (4) 55 (2) 39 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 16 (4) 3 (3) 5 (3) 9 (3) 11 (1) 26 (1) 29 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 16 (9) 45 (4) 55 (2) 38 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (16) </p>
            <button class="run" title="lines run...">28 run</button>
            <button class="not_run" title="lines not run...">9 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 28</b>: 13 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (8) 10 (3) 6 (2) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 12 (6) 5 (4) 8 (2) 13 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (8) 10 (3) 6 (2) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 16 (6) 5 (4) 10 (2) 13 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (13) </p>
            <button class="run" title="lines run...">25 run</button>
            <button class="not_run" title="lines not run...">12 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 29</b>: 13 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (13) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 23 (8) 11 (4) 13 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (13) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 11 (11) 13 (2) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (13) </p>
            <button class="run" title="lines run...">29 run</button>
            <button class="not_run" title="lines not run...">8 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 30</b>: 9 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 21 (6) 42 (3) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 23 (6) 48 (3) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 30 (3) 9 (3) 13 (3) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 33 (3) 11 (3) 15 (3) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (9) </p>
            <button class="run" title="lines run...">25 run</button>
            <button class="not_run" title="lines not run...">12 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 31</b>: 6 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 33 (6) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 48 (3) 45 (3) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 21 (3) 25 (3) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 33 (3) 39 (3) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (6) </p>
            <button class="run" title="lines run...">30 run</button>
            <button class="not_run" title="lines not run...">7 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 32</b>: 6 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 5 (6) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 9 (6) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 5 (6) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 9 (6) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (6) </p>
            <button class="run" title="lines run...">26 run</button>
            <button class="not_run" title="lines not run...">11 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 33</b>: 5 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (5) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 0 (5) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (5) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 0 (5) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (5) </p>
            <button class="run" title="lines run...">12 run</button>
            <button class="not_run" title="lines not run...">25 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full not_run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full not_run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full not_run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full not_run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full not_run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full not_run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 34</b>: 4 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 5 (4) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 13 (2) 19 (2) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 5 (4) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 13 (4) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (4) </p>
            <button class="run" title="lines run...">25 run</button>
            <button class="not_run" title="lines not run...">12 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 35</b>: 4 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 10 (3) 8 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 12 (3) 14 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 10 (3) 8 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 12 (3) 23 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (4) </p>
            <button class="run" title="lines run...">23 run</button>
            <button class="not_run" title="lines not run...">14 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 36</b>: 3 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (3) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 16 (3) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (3) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 16 (3) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (3) </p>
            <button class="run" title="lines run...">28 run</button>
            <button class="not_run" title="lines not run...">9 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 37</b>: 3 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 10 (3) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 16 (3) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 10 (3) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 16 (3) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (3) </p>
            <button class="run" title="lines run...">27 run</button>
            <button class="not_run" title="lines not run...">10 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 38</b>: 3 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 16 (3) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 36 (3) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 16 (3) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 36 (3) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (3) </p>
            <button class="run" title="lines run...">30 run</button>
            <button class="not_run" title="lines not run...">7 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 39</b>: 1 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> None (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> None (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (1) </p>
            <button class="run" title="lines run...">26 run</button>
            <button class="not_run" title="lines not run...">11 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 40</b>: 1 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 2 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> None (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 4 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> None (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (1) </p>
            <button class="run" title="lines run...">27 run</button>
            <button class="not_run" title="lines not run...">10 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 41</b>: 1 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> None (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 1 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 5 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (1) </p>
            <button class="run" title="lines run...">24 run</button>
            <button class="not_run" title="lines not run...">13 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 42</b>: 1 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 0 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 5 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 0 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 203 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (1) </p>
            <button class="run" title="lines run...">27 run</button>
            <button class="not_run" title="lines not run...">10 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full not_run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full not_run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 43</b>: 1 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 2 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 13 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 2 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 13 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (1) </p>
            <button class="run" title="lines run...">29 run</button>
            <button class="not_run" title="lines not run...">8 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
            <p><b>Path 44</b>: 1 calls (0.0)</p>
                <p><button class="input"><span>&#8594;</span> alo</button> 9 (1) </p>
                <p><button class="input"><span>&#8594;</span> ahi</button> 13 (1) </p>
                <p><button class="input"><span>&#8594;</span> blo</button> 12 (1) </p>
                <p><button class="input"><span>&#8594;</span> bhi</button> 13 (1) </p>
                <p><button class="output"><span>&#8617; return</span></button> Match (1) </p>
            <button class="run" title="lines run...">23 run</button>
            <button class="not_run" title="lines not run...">14 not run</button>
            <pre>
<span class="num"><a href="#1">1</a></span><span><span class="k">def</span> <span class="nf">find_longest_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ahi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bhi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span></span>
<span class="num"><a href="#2">2</a></span><span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Find longest matching block in a[alo:ahi] and b[blo:bhi].</span></span>
<span class="num"><a href="#3">3</a></span><span></span>
<span class="num"><a href="#4">4</a></span><span><span class="sd">        By default it will find the longest match in the entirety of a and b.</span></span>
<span class="num"><a href="#5">5</a></span><span></span>
<span class="num"><a href="#6">6</a></span><span><span class="sd">        If isjunk is not defined:</span></span>
<span class="num"><a href="#7">7</a></span><span></span>
<span class="num"><a href="#8">8</a></span><span><span class="sd">        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where</span></span>
<span class="num"><a href="#9">9</a></span><span><span class="sd">            alo &lt;= i &lt;= i+k &lt;= ahi</span></span>
<span class="num"><a href="#10">10</a></span><span><span class="sd">            blo &lt;= j &lt;= j+k &lt;= bhi</span></span>
<span class="num"><a href="#11">11</a></span><span><span class="sd">        and for all (i&#39;,j&#39;,k&#39;) meeting those conditions,</span></span>
<span class="num"><a href="#12">12</a></span><span><span class="sd">            k &gt;= k&#39;</span></span>
<span class="num"><a href="#13">13</a></span><span><span class="sd">            i &lt;= i&#39;</span></span>
<span class="num"><a href="#14">14</a></span><span><span class="sd">            and if i == i&#39;, j &lt;= j&#39;</span></span>
<span class="num"><a href="#15">15</a></span><span></span>
<span class="num"><a href="#16">16</a></span><span><span class="sd">        In other words, of all maximal matching blocks, return one that</span></span>
<span class="num"><a href="#17">17</a></span><span><span class="sd">        starts earliest in a, and of all those maximal matching blocks that</span></span>
<span class="num"><a href="#18">18</a></span><span><span class="sd">        start earliest in a, return the one that starts earliest in b.</span></span>
<span class="num"><a href="#19">19</a></span><span></span>
<span class="num"><a href="#20">20</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#21">21</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#22">22</a></span><span><span class="sd">        Match(a=0, b=4, size=5)</span></span>
<span class="num"><a href="#23">23</a></span><span></span>
<span class="num"><a href="#24">24</a></span><span><span class="sd">        If isjunk is defined, first the longest matching block is</span></span>
<span class="num"><a href="#25">25</a></span><span><span class="sd">        determined as above, but with the additional restriction that no</span></span>
<span class="num"><a href="#26">26</a></span><span><span class="sd">        junk element appears in the block.  Then that block is extended as</span></span>
<span class="num"><a href="#27">27</a></span><span><span class="sd">        far as possible by matching (only) junk elements on both sides.  So</span></span>
<span class="num"><a href="#28">28</a></span><span><span class="sd">        the resulting block never matches on junk except as identical junk</span></span>
<span class="num"><a href="#29">29</a></span><span><span class="sd">        happens to be adjacent to an &quot;interesting&quot; match.</span></span>
<span class="num"><a href="#30">30</a></span><span></span>
<span class="num"><a href="#31">31</a></span><span><span class="sd">        Here&#39;s the same example as before, but considering blanks to be</span></span>
<span class="num"><a href="#32">32</a></span><span><span class="sd">        junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail</span></span>
<span class="num"><a href="#33">33</a></span><span><span class="sd">        end of the second sequence directly.  Instead only the &quot;abcd&quot; can</span></span>
<span class="num"><a href="#34">34</a></span><span><span class="sd">        match, and matches the leftmost &quot;abcd&quot; in the second sequence:</span></span>
<span class="num"><a href="#35">35</a></span><span></span>
<span class="num"><a href="#36">36</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)</span></span>
<span class="num"><a href="#37">37</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)</span></span>
<span class="num"><a href="#38">38</a></span><span><span class="sd">        Match(a=1, b=0, size=4)</span></span>
<span class="num"><a href="#39">39</a></span><span></span>
<span class="num"><a href="#40">40</a></span><span><span class="sd">        If no blocks match, return (alo, blo, 0).</span></span>
<span class="num"><a href="#41">41</a></span><span></span>
<span class="num"><a href="#42">42</a></span><span><span class="sd">        &gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)</span></span>
<span class="num"><a href="#43">43</a></span><span><span class="sd">        &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)</span></span>
<span class="num"><a href="#44">44</a></span><span><span class="sd">        Match(a=0, b=0, size=0)</span></span>
<span class="num"><a href="#45">45</a></span><span><span class="sd">        &quot;&quot;&quot;</span></span>
<span class="num"><a href="#46">46</a></span><span></span>
<span class="num"><a href="#47">47</a></span><span>        <span class="c1"># CAUTION:  stripping common prefix or suffix would be incorrect.</span></span>
<span class="num"><a href="#48">48</a></span><span>        <span class="c1"># E.g.,</span></span>
<span class="num"><a href="#49">49</a></span><span>        <span class="c1">#    ab</span></span>
<span class="num"><a href="#50">50</a></span><span>        <span class="c1">#    acab</span></span>
<span class="num"><a href="#51">51</a></span><span>        <span class="c1"># Longest matching block is &quot;ab&quot;, but if common prefix is</span></span>
<span class="num"><a href="#52">52</a></span><span>        <span class="c1"># stripped, it&#39;s &quot;a&quot; (tied with &quot;b&quot;).  UNIX(tm) diff does so</span></span>
<span class="num"><a href="#53">53</a></span><span>        <span class="c1"># strip, so ends up claiming that ab is changed to acab by</span></span>
<span class="num"><a href="#54">54</a></span><span>        <span class="c1"># inserting &quot;ca&quot; in the middle.  That&#39;s minimal but unintuitive:</span></span>
<span class="num"><a href="#55">55</a></span><span>        <span class="c1"># &quot;it&#39;s obvious&quot; that someone inserted &quot;ac&quot; at the front.</span></span>
<span class="num"><a href="#56">56</a></span><span>        <span class="c1"># Windiff ends up at the same place as diff, but by pairing up</span></span>
<span class="num"><a href="#57">57</a></span><span>        <span class="c1"># the unique &#39;b&#39;s and then matching the first two &#39;a&#39;s.</span></span>
<span class="num"><a href="#58">58</a></span><span></span>
<span class="num"><a href="#59">59</a></span><span class="full run">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b2j</span><span class="p">,</span> <span class="n">isbjunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bjunk</span><span class="o">.</span><span class="fm">__contains__</span></span>
<span class="num"><a href="#60">60</a></span><span class="full run">        <span class="k">if</span> <span class="n">ahi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#61">61</a></span><span class="full not_run">            <span class="n">ahi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></span>
<span class="num"><a href="#62">62</a></span><span class="full run">        <span class="k">if</span> <span class="n">bhi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span></span>
<span class="num"><a href="#63">63</a></span><span class="full not_run">            <span class="n">bhi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></span>
<span class="num"><a href="#64">64</a></span><span class="full run">        <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">alo</span><span class="p">,</span> <span class="n">blo</span><span class="p">,</span> <span class="mi">0</span></span>
<span class="num"><a href="#65">65</a></span><span>        <span class="c1"># find longest junk-free match</span></span>
<span class="num"><a href="#66">66</a></span><span>        <span class="c1"># during an iteration of the loop, j2len[j] = length of longest</span></span>
<span class="num"><a href="#67">67</a></span><span>        <span class="c1"># junk-free match ending with a[i-1] and b[j]</span></span>
<span class="num"><a href="#68">68</a></span><span class="full run">        <span class="n">j2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#69">69</a></span><span class="full run">        <span class="n">nothing</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="num"><a href="#70">70</a></span><span class="full run">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alo</span><span class="p">,</span> <span class="n">ahi</span><span class="p">):</span></span>
<span class="num"><a href="#71">71</a></span><span>            <span class="c1"># look at all instances of a[i] in b; note that because</span></span>
<span class="num"><a href="#72">72</a></span><span>            <span class="c1"># b2j has no junk keys, the loop is skipped if a[i] is junk</span></span>
<span class="num"><a href="#73">73</a></span><span class="full run">            <span class="n">j2lenget</span> <span class="o">=</span> <span class="n">j2len</span><span class="o">.</span><span class="n">get</span></span>
<span class="num"><a href="#74">74</a></span><span class="full run">            <span class="n">newj2len</span> <span class="o">=</span> <span class="p">{}</span></span>
<span class="num"><a href="#75">75</a></span><span class="full run">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b2j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nothing</span><span class="p">):</span></span>
<span class="num"><a href="#76">76</a></span><span>                <span class="c1"># a[i] matches b[j]</span></span>
<span class="num"><a href="#77">77</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">blo</span><span class="p">:</span></span>
<span class="num"><a href="#78">78</a></span><span class="full run">                    <span class="k">continue</span></span>
<span class="num"><a href="#79">79</a></span><span class="full run">                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">bhi</span><span class="p">:</span></span>
<span class="num"><a href="#80">80</a></span><span class="full run">                    <span class="k">break</span></span>
<span class="num"><a href="#81">81</a></span><span class="full not_run">                <span class="n">k</span> <span class="o">=</span> <span class="n">newj2len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2lenget</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#82">82</a></span><span class="full not_run">                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">bestsize</span><span class="p">:</span></span>
<span class="num"><a href="#83">83</a></span><span class="full not_run">                    <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span></span>
<span class="num"><a href="#84">84</a></span><span class="full run">            <span class="n">j2len</span> <span class="o">=</span> <span class="n">newj2len</span></span>
<span class="num"><a href="#85">85</a></span><span></span>
<span class="num"><a href="#86">86</a></span><span>        <span class="c1"># Extend the best by non-junk elements on each end.  In particular,</span></span>
<span class="num"><a href="#87">87</a></span><span>        <span class="c1"># &quot;popular&quot; non-junk elements aren&#39;t in b2j, which greatly speeds</span></span>
<span class="num"><a href="#88">88</a></span><span>        <span class="c1"># the inner loop above, but also means &quot;the best&quot; match so far</span></span>
<span class="num"><a href="#89">89</a></span><span>        <span class="c1"># doesn&#39;t contain any junk *or* popular non-junk elements.</span></span>
<span class="num"><a href="#90">90</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#91">91</a></span><span class="full not_run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#92">92</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#93">93</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#94">94</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#95">95</a></span><span class="full run">              <span class="ow">not</span> <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#96">96</a></span><span class="full run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#97">97</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="num"><a href="#98">98</a></span><span></span>
<span class="num"><a href="#99">99</a></span><span>        <span class="c1"># Now that we have a wholly interesting match (albeit possibly</span></span>
<span class="num"><a href="#100">100</a></span><span>        <span class="c1"># empty!), we may as well suck up the matching junk on each</span></span>
<span class="num"><a href="#101">101</a></span><span>        <span class="c1"># side of it too.  Can&#39;t think of a good reason not to, and it</span></span>
<span class="num"><a href="#102">102</a></span><span>        <span class="c1"># saves post-processing the (possibly considerable) expense of</span></span>
<span class="num"><a href="#103">103</a></span><span>        <span class="c1"># figuring out what to do with it.  In the case of an empty</span></span>
<span class="num"><a href="#104">104</a></span><span>        <span class="c1"># interesting match, this is clearly the right thing to do,</span></span>
<span class="num"><a href="#105">105</a></span><span>        <span class="c1"># because no other kind of match is possible in the regions.</span></span>
<span class="num"><a href="#106">106</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span> <span class="o">&gt;</span> <span class="n">alo</span> <span class="ow">and</span> <span class="n">bestj</span> <span class="o">&gt;</span> <span class="n">blo</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#107">107</a></span><span class="full not_run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#108">108</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span></span>
<span class="num"><a href="#109">109</a></span><span class="full not_run">            <span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span> <span class="o">=</span> <span class="n">besti</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestsize</span><span class="o">+</span><span class="mi">1</span></span>
<span class="num"><a href="#110">110</a></span><span class="full run">        <span class="k">while</span> <span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">ahi</span> <span class="ow">and</span> <span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span> <span class="o">&lt;</span> <span class="n">bhi</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#111">111</a></span><span class="full run">              <span class="n">isbjunk</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">])</span> <span class="ow">and</span> \</span>
<span class="num"><a href="#112">112</a></span><span class="full not_run">              <span class="n">a</span><span class="p">[</span><span class="n">besti</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">bestj</span><span class="o">+</span><span class="n">bestsize</span><span class="p">]:</span></span>
<span class="num"><a href="#113">113</a></span><span class="full not_run">            <span class="n">bestsize</span> <span class="o">=</span> <span class="n">bestsize</span> <span class="o">+</span> <span class="mi">1</span></span>
<span class="num"><a href="#114">114</a></span><span></span>
<span class="num"><a href="#115">115</a></span><span class="full run">        <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="n">besti</span><span class="p">,</span> <span class="n">bestj</span><span class="p">,</span> <span class="n">bestsize</span><span class="p">)</span></span>
            </pre>
    </div>
</div>
<i class="bi bi-arrow-down"></i>
</body>
</html>
